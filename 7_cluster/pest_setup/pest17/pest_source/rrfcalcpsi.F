       program rrfcalcpsi

C -- Program RRFCALCPSI reads a run results file generated by PEST_HP. It records
C    objective functions. These are calculated according to weights and covariance matrices
C    supplied in a PEST control file.

       use pestdata
       implicit none

       logical  :: lexist
       integer  :: ifail,ierr,jfail
       integer  :: n,n1,i,j,iline
       integer  :: mpar,mobs,ipar,jpar,iobs,jobs,irow
       integer  :: mxobscov,igroup,iobsgp,igpnm
       integer  :: w1dim,w2dim,jcov,info,ldu,ldvt
       integer  :: icount,icountfail,ifail3,parindex,oldparindex
       integer  :: irestart,pfile,matdim1,ipstart,ireg
       integer  :: nregadjpar,nregobs
       integer  :: lw(10),rw(10)

       double precision :: dtemp,sum1
       double precision :: psi
       double precision :: u(1,1),vt(1,1)
       double precision :: priorpar(1)

       character (len=4)    :: aext
       character (len=10)   :: aversion
       character (len=10)   :: anobsgpp1
       character (len=12)   :: aapar
       character (len=15)   :: aline
       character (len=20)   :: aaobs,atemp20
       character (len=100)  :: afmt
       character (len=200)  :: asource
       character (len=256)  :: rrffile,pestfile,psifile
       character (len=256)  :: arrffile,apestfile,apsifile

       integer, allocatable :: parorder(:),obsorder(:)
       integer, allocatable :: irgp(:)
       integer, allocatable :: ispriorgp(:)
       double precision, allocatable :: w1(:),w2(:)
       double precision, allocatable :: refobs(:)
       double precision, allocatable :: psisub(:)

C -- Initialization

#ifndef UNIX
#ifdef LAHEY
       open(unit=*,action='read',carriagecontrol='list')
#endif
#endif

       include 'version.inc'
       write(6,10) trim(aversion)
10     format(/,' RRFCALCPSI Version ',a,'. Watermark Numerical ',
     + 'Computing.')
#ifdef NO_CMDLINE
       write(*,*)
1      write(*,'(a)') ' ENTER COMMAND LINE ARGUMENTS > '
       read(*,'(a)',ERR=1) CLINE
#else
       call pgetcl(cline)
#endif

       ldu=1
       ldvt=1
       nregadjpar=0
       ireg=0
       oldparindex=0
       parindex=0

! -- The command line is parsed.

       if(cline.eq.' ') go to 9000
       call spacesub(cline)
       call linspl(ifail,4,lw,rw,cline)
       if(ifail.eq.0) go to 9000
       call linspl(ifail,3,lw,rw,cline)
       if(ifail.ne.0) go to 9000
       rrffile=cline(lw(1):rw(1))
       pestfile=cline(lw(2):rw(2))
       psifile=cline(lw(3):rw(3))
       call remchar(rrffile,char(211))
       call remchar(pestfile,char(211))
       call remchar(psifile,char(211))
       n=len_trim(rrffile)
       n1=n-3
       if(n1.lt.1)n1=1
       aext=rrffile(n1:n)
       call lowcas(aext)
       if(aext.ne.'.rrf') rrffile=trim(rrffile)//'.rrf'
       n=len_trim(pestfile)
       n1=n-3
       if(n1.lt.1)n1=1
       aext=pestfile(n1:n)
       call lowcas(aext)
       if(aext.ne.'.pst') pestfile=trim(pestfile)//'.pst'

C -- The RRF file is opened.

       call addquote(rrffile,arrffile)
       open(unit=10,file=rrffile,status='old',action='read',
     + iostat=ierr)
       if(ierr.ne.0)then
         write(errmsg,100) trim(arrffile)
100      format('Cannot open file ',a,'.')
         go to 9890
       end if

C -- The PEST input dataset is read.

       write(6,*)
       call addquote(pestfile,apestfile)
       inquire(file=pestfile,exist=lexist)
       if(.not.lexist)then
         write(errmsg,105) trim(apestfile)
105      format('File ',a,' does not exist.')
         go to 9890
       end if
       write(6,110) trim(apestfile)
110    format(' - reading PEST control file ',a,'...')
       irestart=0
       p1start=0
       pfile=0
       call read_pest_data(ifail,irestart,p1start,pfile,pestfile)
       if(ifail.ne.0) go to 9890
       if(pestmode.eq.3) ireg=1
       if(nobs.eq.0)then
         write(errmsg,120)
120      format('No observations cited in PEST control file.')
         go to 9890
       end if
       if(maxcompdim.gt.1)then
         write(errmsg,130)
130      format('RRFCALCPSI does not permit MAXCOMPDIM to be set ',
     +   'to greater than zero in PEST control file.')
         go to 9890
       end if
       if(nobsgp.eq.0)then
         write(errmsg,129)
129      format('The NOBSGP variable (number of observation groups) ',
     +   'is missing or set to zero in PEST control file.')
         go to 9890
       end if
       write(6,131) trim(apestfile)
131    format(' - PEST control file ',a,' read ok.')

C -- Now we read the header to the run results file. We also ensure compatibility
C    with the PEST control file.

       write(6,*)
       write(6,132) trim(arrffile)
132    format(' - reading header to run results file ',a,'...')
       allocate(parorder(npar),obsorder(nobs),stat=ierr)
       if(ierr.ne.0) go to 9200
       parorder=0        ! an array
       obsorder=0        ! an array
       iline=1
       read(10,'(a)',end=9100,err=9150) cline
       call lowcas(cline)
       if(cline.ne.'* case dimensions')then
         write(errmsg,140) trim(arrffile)
140      format('First line of file ',a,' should be ',
     +   '"* case dimensions".')
         go to 9890
       end if
       iline=iline+1
       read(10,*,end=9100,err=9150) mpar,mobs
       if((mpar.ne.npar).or.(mobs.ne.nobs))then
         write(errmsg,150) trim(arrffile)
150      format('Number of parameters or observations in file ',a,
     +   ' differ from that in PEST control file.')
         go to 9890
       end if
       iline=iline+1
       read(10,'(a)',end=9100,err=9150) cline
       if(cline.ne.'* parameter names')then
         write(errmsg,160) trim(arrffile)
160      format('Third line of file ',a,' should be ',
     +   '"* parameter names".')
         go to 9890
       end if
       jpar=0
       do ipar=1,npar
165      continue
         iline=iline+1
         read(10,'(a)',end=9100,err=9150) cline
         if(cline.eq.' ') go to 165
         call linspl(ifail,1,lw,rw,cline)
         aapar=cline(lw(1):rw(1))
         call lowcas(aapar)
         if(aapar(1:1).eq.'*')then
           call writint(aline,iline)
           write(errmsg,167) trim(aline),trim(arrffile)
167        format('Unexpected "*" character encountered at line ',a,
     +     ' of file ',a,'.')
           go to 9890
         end if
         call which1(ifail,npar,jpar,apar,aapar)
         if(ifail.ne.0)then
           write(errmsg,170) trim(aapar),trim(arrffile)
170        format('Parameter ',a,' cited in "parameter names" section ',
     +     'of file ',a,' is not cited in PEST control file.')
           go to 9890
         end if
         parorder(ipar)=jpar
       end do
       do ipar=1,npar
         if(parorder(ipar).eq.0)then
           write(errmsg,180) trim(apar(ipar))
180        format('Parameter "',a,'" cited in PEST control file is ',
     +     'not cited in run results file.')
           go to 9890
         end if
       end do

       iline=iline+1
       read(10,'(a)',end=9100,err=9150) cline
       if(cline.ne.'* observation names')then
         call writint(aline,iline)
         write(errmsg,181) trim(aline),trim(arrffile)
181      format('Line number ',a,' of file ',a,' should be ',
     +   '"* observation names".')
         go to 9890
       end if
       jobs=0
       do iobs=1,nobs
185      continue
         iline=iline+1
         read(10,'(a)',end=9100,err=9150) cline
         if(cline.eq.' ') go to 185
         call linspl(ifail,1,lw,rw,cline)
         aaobs=cline(lw(1):rw(1))
         call lowcas(aaobs)
         if(aaobs(1:1).eq.'*')then
           call writint(aline,iline)
           write(errmsg,167) trim(aline),trim(arrffile)
           go to 9890
         end if
         call which1(ifail,nobs,jobs,aobs,aaobs)
         if(ifail.ne.0)then
           write(errmsg,190) trim(aaobs),trim(arrffile)
190        format('Observation ',a,' cited in "parameter names" ',
     +     'section of file ',a,' is not cited in PEST control file.')
           go to 9890
         end if
         obsorder(iobs)=jobs
       end do
       do iobs=1,nobs
         if(obsorder(iobs).eq.0)then
           write(errmsg,200) trim(aobs(iobs))
200        format('Observation "',a,'" cited in PEST control file is ',
     +     'not cited in run results file.')
           go to 9890
         end if
       end do

C -- We establish which groups are regularisation groups.

        ALLOCATE(IRGP(NOBSGP),STAT=IERR)
        IF(IERR.NE.0) GO TO 9200
        DO I=1,NOBSGP
          IRGP(I)=0
        END DO
        NREGOBS=0
        IF(IREG.EQ.1)THEN
          DO I=1,NOBSGP
            IF(OBGNME(I)(1:5).EQ.'regul')THEN
              IRGP(I)=1
              NREGOBS=NREGOBS+1
            END IF
          END DO
          IF(NREGOBS.EQ.0)THEN
            WRITE(ERRMSG,5019) TRIM(APESTFILE)
5019        FORMAT('According to PEST control file ',a,', PEST is run ',
     +      'in regularisation mode. However no regularisation group ',
     +      'exists in the "observation groups" section of this file.')
            GO TO 9890
          END IF
        END IF
5020    CONTINUE

C -- SOME PROCESSING OF COVARIANCE MATRIX DATA IS UNDERTAKEN.

        MXOBSCOV=0
        DO 6530 IGROUP=1,NOBSGP
          IF(.NOT.COVIND(IGROUP)) GO TO 6530
          ICOUNT=0
          DO 6520 I=1,NXROW
            IF(NOBGNM(I).EQ.IGROUP) THEN
              ICOUNT=ICOUNT+1
            END IF
6520      CONTINUE
          IF(ICOUNT.GT.MXOBSCOV)MXOBSCOV=ICOUNT
6530    CONTINUE
        IF(MXOBSCOV.EQ.0)NUMCOV=0

C -- THE GENERAL WORK VECTOR W2 IS ALLOCATED.

        w1dim=mxobscov
        w2dim=6*mxobscov
        ALLOCATE(w1(w1dim),W2(W2DIM),STAT=IERR)
        IF(IERR.NE.0) GO TO 9200

C -- IF COVARIANCE MATRIX IS SUPPLIED FOR AN OBSERVATION GROUP, THAT GROUP
C    MUST PERTAIN TO OBSERVATIONS OR PRIOR INFORMATION, BUT NOT BOTH.

        IF(NUMCOV.GT.0)THEN
          IF(NPRIOR.GT.0)THEN
            DO 6601 I=NOBS+1,NXROW
              IGROUP=NOBGNM(I)
              DO 6602 JCOV=1,NUMCOV
                IF(IGROUP.EQ.COVGP(JCOV))THEN
                  DO 6603 J=1,NOBS
                    IF(NOBGNM(J).EQ.IGROUP) THEN
                      WRITE(ERRMSG,6599)
6599                  FORMAT('If a covariance matrix is supplied ',
     +                'for an observation group in the PEST control ',
     +                'file, that group must ',
     +                'pertain to observations or prior information ',
     +                'but not both.')
                      GO TO 9890
                    end if
6603              CONTINUE
                END IF
6602          end do
6601        end do
          END IF
        END IF

C -- IF ANY COVARIANCE MATRICES ARE PROVIDED, THE ROTATION MATRICES ARE
C    NOW CALCULATED.

        IF(NUMCOV.NE.0)THEN
          DO 6650 JCOV=1,NUMCOV
            IF(NOBSCOV(JCOV).LE.0) GO TO 6650
            IGROUP=COVGP(JCOV)
            IF(NOBSCOV(JCOV).EQ.1)THEN
              W1(1)=COVAR(JCOV)%DVAL(1,1)
              COVAR(JCOV)%DVAL(1,1)=1.0D0
            ELSE
              CALL DGESVD('O','N',NOBSCOV(JCOV),NOBSCOV(JCOV),
     +        COVAR(JCOV)%DVAL,NOBSCOV(JCOV),W1,U,LDU,VT,LDVT,
     +        W2,W2DIM,INFO)
              IF(INFO.NE.0)THEN
                WRITE(ERRMSG,6604) TRIM(OBGNME(IGROUP))
6604            FORMAT('Cannot calculate eigenvalues for the ',
     +          'covariance matrix supplied for observation group "',
     +          a,'".')
                GO TO 9890
              END IF
              CALL VECTOR_REVERSE(NOBSCOV(JCOV),W1)                ! For compatibility with PEST
              CALL MATRIX_REVERSE(NOBSCOV(JCOV),NOBSCOV(JCOV),     ! For compatibility with PEST
     +        NOBSCOV(JCOV),COVAR(JCOV)%DVAL)
            END IF
            J=0
            DO 6640 I=1,NXROW
              IF(NOBGNM(I).EQ.IGROUP)THEN
                J=J+1
                IF(W1(J).LE.0.0D0) THEN
                  WRITE(ERRMSG,6604) TRIM(OBGNME(IGROUP))
                  GO TO 9890
                END IF
                OWGHT(I)=1.0/W1(J)
              END IF
6640        CONTINUE
6650      CONTINUE
        END IF

C -- AFFECTED OBSERVATION WEIGHTS WERE RE-CALCULATED FROM RESPECTIVE EIGENVALUES
C    ABOVE. NOW THE OBSERVATIONS ARE ALSO ROTATED.

        IF(NUMCOV.NE.0)THEN
          DO 6700 JCOV=1,NUMCOV
            IF(NOBSCOV(JCOV).LE.0) GO TO 6700
            IGROUP=COVGP(JCOV)
            I=0
            DO 6670 J=1,NXROW
              IF(NOBGNM(J).EQ.IGROUP)THEN
                I=I+1
                W1(I)=OVAL(J)
              END IF
6670        CONTINUE
            CALL ROTATE(1,NOBSCOV(JCOV),NOBSCOV(JCOV),1,1,1,
     +      COVAR(JCOV)%DVAL,W1,X,W2,IGROUP,NXROW,NOBGNM)
            I=0
            DO 6680 J=1,NXROW
              IF(NOBGNM(J).EQ.IGROUP)THEN
                I=I+1
                OVAL(J)=W1(I)
              END IF
6680        CONTINUE
6700      CONTINUE
        END IF

C -- IF THERE IS ANY PRIOR INFORMATION PRESENT, AND ITS WEIGHTS ARE CORRELATED,
C    THEN THE APPROPRIATE PART OF THE X VECTOR IS ROTATED.

        MATDIM1=NXROW
        IF(NUMCOV.NE.0)THEN
          IF(NPRIOR.NE.0)THEN
            IPSTART=NXROW-NPRIOR+1
            DO 6750 JCOV=1,NUMCOV
              IGROUP=COVGP(JCOV)
              DO 6720 I=IPSTART,NXROW
                IF(NOBGNM(I).EQ.IGROUP)THEN
                  CALL ROTATE(2,NOBSCOV(JCOV),NOBSCOV(JCOV),MATDIM1,
     +            NESPAR,IPSTART,COVAR(JCOV)%DVAL,W1,X,W2,IGROUP,
     +            NXROW,NOBGNM)
                  GO TO 6750
                END IF
6720          CONTINUE
6750        CONTINUE
          END IF
        END IF

C -- BEFORE THE FIRST MODEL RUN, REGULARISATION WEIGHTS ARE ADJUSTED.

        IF(IREG.EQ.1)THEN
          DO 5120 IROW=1,NXROW
            IGPNM=NOBGNM(IROW)
            IF(IRGP(IGPNM).NE.0) OWGHT(IROW)=OWGHT(IROW)*WFINIT*WFINIT
5120      CONTINUE
        END IF

C -- We establish whether an observation group is a prior information group.

        allocate(ispriorgp(nobsgp),stat=ierr)
        if(ierr.ne.0) go to 9200
        ispriorgp=0                    ! an array
        if(nprior.gt.0)then
          do iobs=nobs+1,nxrow
            iobsgp=nobgnm(iobs)
            ispriorgp(iobsgp)=1
          end do
        end if
        allocate(refobs(nxrow),psisub(nobsgp),stat=ierr)
        if(ierr.ne.0) go to 9200

C -- We record the header to the output file.

        call addquote(psifile,apsifile)
        open(unit=20,file=psifile)
        write(20,970)
970     format(t22,'Observation group objective functions --->')
        write(20,975,advance='no')
975     format('parameter_set_index  ')
        do iobsgp=1,nobsgp
          atemp20=adjustl(obgnme(iobsgp))
          write(20,'(a20)',advance='no') atemp20
        end do
        atemp20='total'
        atemp20=adjustl(atemp20)
        write(20,'(a20)',advance='no') atemp20
        write(20,'(a)') 'source_of_parameters'

C -- This is where the big loop begins.

C -- First we read the next part of the run results file.

        write(6,980)
980     format(/,' - reading run results file and writing ',
     +  'output file...')
        icount=0
        icountfail=0
1000    continue
        ifail3=0
        iline=iline+1
        read(10,'(a)',end=2000,err=2000) cline
        if(cline.eq.' ') go to 1000
        call lowcas(cline)
        if(cline(1:21).ne.'* parameter set index')then
          call writint(aline,iline)
          write(errmsg,1010) trim(aline)
1010      format('Line ',a,' of run result file expected to be ',
     +    '"* parameter set index"')
          icountfail=1
          go to 2000
        end if
        iline=iline+1
        oldparindex=parindex
        read(10,*,err=1011,end=1011) parindex
        if(parindex.ne.oldparindex+1)then
            call writint(aline,iline)
            write(errmsg,10211) trim(aline),trim(arrffile)
10211       format('Parameter set indices in a run results file ',
     +      'must be sequential, starting at one. Violation occurs ',
     +      'at line ',a,' of file ',a,'.')
            go to 9890
        end if
        go to 1025
1011    continue
        call writint(aline,iline)
        write(errmsg,1020) trim(aline),trim(arrffile)
1020    format('Cannot read parameter set index from line ',a,
     +  ' of file ',a,'.')
        icountfail=1
        go to 2000
1025    continue
        iline=iline+1
        read(10,'(a)',end=1021,err=9150) cline
        if(cline.eq.' ') go to 1025
        call lowcas(cline)
        if(cline(1:25).ne.'* parameter values source')then
          call writint(aline,iline)
          write(errmsg,1016) trim(aline)
1016      format('Line ',a,' of run result file expected to be ',
     +    '"* parameter values source"')
          icountfail=1
          go to 2000
        end if
        iline=iline+1
        read(10,'(a)',end=1021,err=9150) asource
        asource=adjustl(asource)
        iline=iline+1
        read(10,'(a)',end=1021) cline
        go to 1023
1021    icountfail=1
        write(errmsg,1022) trim(arrffile)
1022    format('Uexpected end encountered to file ',a,'.')
        go to 2000
1023    continue
        cline=adjustl(cline)
        call lowcas(cline)
        if(cline(1:18).ne.'* parameter values')then
          call writint(aline,iline)
          write(errmsg,1030) trim(aline)
1030      format('Line ',a,' of run results file expected to be ',
     +    '"* parameter values"')
          icountfail=1
          go to 2000
        end if
        do ipar=1,npar
          iline=iline+1
          read(10,*,err=1035,end=1035) pval(parorder(ipar))
          go to 1045
1035      continue
          call writint(aline,iline)
          write(errmsg,1040) trim(aline)
1040      format('Cannot read parameter value from line ',a,'.')
          icountfail=1
          go to 2000
1045      continue
        end do
        iline=iline+1
        read(10,'(a)',end=1021,err=9150) cline
        continue
        cline=adjustl(cline)
        call lowcas(cline)
        if(cline(1:21).ne.'* model output values')then
          call writint(aline,iline)
          write(errmsg,1050) trim(aline)
1050      format('Line ',a,' of run results file expected to be ',
     +    '"* model output values"')
          icountfail=1
          go to 2000
        end if
        do iobs=1,nobs
          iline=iline+1
          read(10,*,err=1055,end=1055) refobs(obsorder(iobs))
          go to 1063
1055      continue
          call writint(aline,iline)
          write(errmsg,1060) trim(aline)
1060      format('Cannot read model output value from line ',a,
     +    ' of run results file.')
          icountfail=1
          go to 2000
1063      continue
        end do
        dtemp=refobs(1)
        if((dtemp.lt.-1.10d35).and.(dtemp.gt.-1.12d35))ifail3=1
        if((dtemp.lt.-1.21d35).and.(dtemp.gt.-1.23d35))ifail3=1

C -- IF ANY COVARIANCE MATRICES HAVE BEEN SUPPLIED, THEN THE
C    OBSERVATIONS ARE ROTATED.

        if(ifail3.eq.0)then
        IF(NUMCOV.GT.0)THEN
          DO 6800 JCOV=1,NUMCOV
            IF(NOBSCOV(JCOV).LE.0) GO TO 6800
            IGROUP=COVGP(JCOV)
            I=0
            DO 6810 J=1,NOBS
              IF(NOBGNM(J).EQ.IGROUP)THEN
                I=I+1
                W1(I)=REFOBS(J)
              END IF
6810        CONTINUE
            CALL ROTATE(1,NOBSCOV(JCOV),NOBSCOV(JCOV),1,1,1,
     +      COVAR(JCOV)%DVAL,W1,X,W2,IGROUP,NXROW,NOBGNM)
            I=0
            DO 6820 J=1,NXROW
              IF(NOBGNM(J).EQ.IGROUP)THEN
                I=I+1
                REFOBS(J)=W1(I)
              END IF
6820        CONTINUE
6800      CONTINUE
        END IF
        end if

C -- Prior information is now calculated.

        IF(NPRIOR.NE.0)THEN
          CALL PRRCLC(JFAIL,NPAR,NOBS,NXROW,NESPAR,PVAL,
     +    ITRANS,REFOBS,X,CLINE,SCALE,NREGADJPAR,PRIORPAR)
          IF(JFAIL.NE.0) GO TO 9890
        END IF

C -- Objective function components are now calculated.

        IF(IFAIL3.eq.0)THEN
          CALL OBJCLC(1,PSI,NXROW,NPRIOR,NOBS,REFOBS,OVAL,OWGHT,NOBGNM,
     +    NOBSGP,IRGP,SUM1)
          DO I=1,NOBSGP
            CALL OBJCLC(-I,PSISUB(I),NXROW,NPRIOR,NOBS,REFOBS,OVAL,
     +      OWGHT,NOBGNM,NOBSGP,IRGP,SUM1)
          END DO
        ELSE
          PSI=-1.1E35
          DO I=1,NOBSGP
            if(ispriorgp(i).eq.0)then
              PSISUB(I)=PSI
            else
              CALL OBJCLC(-I,PSISUB(I),NXROW,NPRIOR,NOBS,REFOBS,OVAL,
     +        OWGHT,NOBGNM,NOBSGP,IRGP,SUM1)
            end if
          END DO
        END IF

C -- The objective function details are recorded.

        call writint(anobsgpp1,nobsgp+1)
        afmt='(5x,i8,t20,'//trim(anobsgpp1)//'(1pg14.7,6x),2x,a)'
        write(20,afmt) parindex,(psisub(iobsgp),iobsgp=1,nobsgp),
     +                 psi,trim(asource)
        icount=icount+1

        go to 1000

C -- This is the end of the loop. Now we tidy up.

2000    if(icountfail.ne.0)then
          if(icount.eq.0) then
            go to 9890
          else
            errmsg=' '//trim(errmsg)
            call writmess(6,errmsg)
            write(6,*)
          end if
        end if
        call writint(atemp20,icount)
        write(6,2010) trim(atemp20)
2010    format(' - data for ',a,' parameter sets read from ',
     +  'run results file.')
        write(6,2020) trim(apsifile)
2020    format(' - file ',a,' written ok.')

        if(pestmode.eq.3)then
          write(6,2030)
2030      format(/,' Note:')
          write(6,2040)
2040      format(' The PEST conrol file instructs PEST to run in ',
     +    '"regularisation" mode.')
          write(6,2050)
2050      format(' The initial regularisation weight factor (WFINIT) ',
     +    'was used in calculating ',/,' components of the objective ',
     +    'function pertaining to regularisation groups.')
        else if(pestmode.eq.4)then
          write(6,2030)
          write(6,2060)
2060      format(' The PEST conrol file instructs PEST to run in ',
     +    '"pareto" mode.')
          write(6,2070)
2070      format(' Weights provided in the PEST control file are ',
     +    'used directly in calculating',/,' objective function ',
     +    'components. No weight factor is applied.')
        end if

       go to 9900

9000   continue
       write(6,9010)
9010   format(/,' RRFCALCPSI is run using the command:',/)
       write(6,9020)
9020   format('     rrfcalcpsi rrffile pestfile psifile',/)
       write(6,9030)
9030   format(' where',/)
       write(6,9050)
9050   format('     rrffile  is a PEST_HP run results file,')
       write(6,9060)
9060   format('     pestfile is a PEST control file, and')
       write(6,9070)
9070   format('     psifile  is a file in which objective ',
     + 'functions will be recorded.')
       go to 9999

9100   write(errmsg,9110)
9110   format('Premature end encountered to run results file.')
       go to 9890

9150   continue
       call writint(aline,iline)
       write(errmsg,9160) trim(aline)
9160   format('Error encountered reading line ',a,
     + ' of run results file.')
       go to 9890

9200   write(errmsg,9210)
9210   format('Cannot allocate sufficient memory to continue ',
     + 'execution.')
       go to 9890

9890   continue
       errmsg=' '//trim(errmsg)
       call writmess(6,errmsg)

9900   continue
       call pest_data_deallocate(ifail)
       deallocate(parorder,obsorder,stat=ierr)
       deallocate(irgp,stat=ierr)
       deallocate(ispriorgp,stat=ierr)
       deallocate(w1,w2,stat=ierr)
       deallocate(refobs,stat=ierr)
       deallocate(psisub,stat=ierr)

       close(unit=10,iostat=ierr)
       close(unit=20,iostat=ierr)
       close(unit=30,iostat=ierr)

9999   continue
       end



        SUBROUTINE NUMRD(IFAIL,ITYPE,LW,RW,IVAL,RVAL,CLINE)

C -- SUBROUTINE NUMRD READS A NUMBER FROM PART OF A STRING

        INTEGER IFAIL,RW,LW,LN,IVAL
        INTEGER ITYPE
        DOUBLE PRECISION RVAL
        CHARACTER*(*) CLINE
        CHARACTER*10 FMT

        IFAIL=0
        LN=RW-LW+1
        IF(ITYPE.EQ.0) THEN
          WRITE(FMT,10) LN
10        FORMAT('(I',I2,')')
          READ(CLINE(LW:RW),FMT,ERR=50) IVAL
        ELSE IF(ITYPE.EQ.1) THEN
          WRITE(FMT,20) LN
20        FORMAT('(F',I2,'.0)')
          READ(CLINE(LW:RW),FMT,ERR=50) RVAL
        END IF
        RETURN

50      IFAIL=1
        RETURN

        END



        subroutine addquote(afile,aqfile)

C -- Subroutine ADDQUOTE adds quotes to a filename if it has a space in it.

        implicit none

        character*(*) afile
        character*(*) aqfile
        integer nbb

        if(index(trim(afile),' ').eq.0)then
          aqfile=afile
        else
          aqfile(1:1)='"'
          aqfile(2:)=trim(afile)
          nbb=len_trim(aqfile)+1
          aqfile(nbb:nbb)='"'
        end if

        return
      end



	subroutine writint(atemp,ival)

c	Subroutine WRITINT writes an integer to a character variable.

	integer*4 ival
	character*6 afmt
	character*(*) atemp

	afmt='(i   )'
	write(afmt(3:5),'(i3)') len(atemp)
	write(atemp,afmt)ival
	atemp=adjustl(atemp)
	return
	end




      subroutine writmess(iunit,amessage)

        implicit none

	integer iunit,jend,i,nblc,junit,leadblank,itake,j
        character*(*) amessage
	character (len=20) ablank

	ablank=' '
	itake=0
	j=0
	junit=iunit

        if(amessage.eq.' ')then
          write(junit,*)
          return
        end if
        write(junit,*)
	do i=1,min(20,len(amessage))
	  if(amessage(i:i).ne.' ')go to 21
20      end do
21	leadblank=i-1
	nblc=len_trim(amessage)
5       jend=j+78-itake
	if(jend.ge.nblc) go to 100
	do i=jend,j+1,-1
	if(amessage(i:i).eq.' ') then
	  if(itake.eq.0) then
	     write(junit,'(a)') amessage(j+1:i)
	     itake=2+leadblank
	  else
	     write(junit,'(a)') ablank(1:leadblank+2)//
     +       amessage(j+1:i)
	  end if
	  j=i
	  go to 5
	end if
	end do
	if(itake.eq.0)then
	  write(junit,'(a)') amessage(j+1:jend)
	  itake=2+leadblank
	else
	  write(junit,'(a)') ablank(1:leadblank+2)//
     +    amessage(j+1:jend)
	end if
	j=jend
	go to 5
100     jend=nblc
	if(itake.eq.0)then
	  write(junit,'(a)') amessage(j+1:jend)
	else
	  write(junit,'(a)') ablank(1:leadblank+2)//
     +    amessage(j+1:jend)
	end if
	return


      end


        subroutine linspl(ifail,num,lw,rw,cline)

c -- Subroutine LINSPL splits a line into whitespace-separated substrings.

        integer ifail,nw,nblc,j,i
        integer num
        integer lw(num),rw(num)
        character*(*) cline

        ifail=0
        nw=0
        nblc=len_trim(cline)
        if(nblc.eq.0) then
          ifail=1
          return
        end if
        j=0
5       if(nw.eq.num) return
        do 10 i=j+1,nblc
        if((cline(i:i).ne.' ').and.(cline(i:i).ne.',')
     +  .and.(ichar(cline(i:i)).ne.9)) go to 20
10      continue
        ifail=1
        return
20      nw=nw+1
        lw(nw)=i
        do 30 i=lw(nw)+1,nblc
        if((cline(i:i).eq.' ').or.(cline(i:i).eq.',')
     +  .or.(ichar(cline(i:i)).eq.9)) go to 40
30      continue
        rw(nw)=nblc
        if(nw.lt.num) ifail=1
        return
40      rw(nw)=i-1
        j=rw(nw)
        go to 5

        end



        SUBROUTINE VECTOR_REVERSE(N,VEC)

        IMPLICIT NONE

        INTEGER N,I,N2,J
        DOUBLE PRECISION RTEMP
        DOUBLE PRECISION VEC(N)

        N2=N/2
        DO I=1,N2
          J=N-(I-1)
          RTEMP=VEC(I)
          VEC(I)=VEC(J)
          VEC(J)=RTEMP
        END DO

        RETURN

        END



        SUBROUTINE MATRIX_REVERSE(LDA,M,N,A)

        IMPLICIT NONE

        INTEGER LDA,N,M
        DOUBLE PRECISION A(LDA,N)

        INTEGER N2,I,J,K
        DOUBLE PRECISION RTEMP

        N2=N/2
        DO I=1,N/2
          J=N-(I-1)
          DO K=1,M
            RTEMP=A(K,I)
            A(K,I)=A(K,J)
            A(K,J)=RTEMP
          END DO
        END DO

        RETURN

        END


